/*
 * Реализация вспомогательных функций
 */

#include "real.h"

// длина числа на основе десятичного логарифма
int real::numlen(int num) {
    int len = 1; // 1, потому что впоследствии нам предстоит округлить логарифм до большего
    // или, если num = 0, посчитать этот 0 (так как log10(0) не определён)
    if(num < 0) {
        ++len;
        num *= -1;
    }
    if(num > 0) { // если n --- ненулевое число
        len += (int)(log10(num));
    }
    return len;
}

// Преобразовывает строку в число, где str --- указатель на начало строки,
// index --- указатель на значение смещения от начала строки.
// После выполнения функции index хранит в себе индекс следующего за числом символа.
void real::int_to_string(int num, char *str, int *index) {
    if(num < 0) {
        num *= -1;
        *str = '-';
    }
    if(num == 0) {
        *str = '0';
    }
    while(num > 0) {
        *(str + *index) = '0' + (num % 10);
        num /= 10;
    }
    ++(*index);
}


// Десятичный логарифм. В рамках задачи не требуется высокая точность, поэтому используется float
float real::log10(int n) {
    float num = (float)n;
    const float e = 2.7182818284590452353602874713527f;
    if (num <= 0) { // логарифм не определён для неположительных чисел
        throw ILLEGAL_NUMBER;
    }
    // приближение к реальному значению логарифма находится глупым алгоритмом
    float result = 0;
    while (num > 1.f) {
        num /= e;
        ++result;
    }
    while (num < .25f) {
        num *= e;
        ++result;
    }
    --num;
    // для более точного результата находим сумму ряда Тейлора
    float sum = 1.f, z = num; // z --- это num в соответствующей степени
    // В общем случае требовалось бы значительно больше слагаемых, но для решения текущих
    // задач точность, которую дают 10 слагаемых, вполне приемлема
    for (int k = 0; k < 10; ++k) {
        result += z * sum / (k + 1);
        z *= num;
        sum = -sum;
    }
    return result;
}